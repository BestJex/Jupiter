# Jupiter开发文档

[TOC]



## 功能需求

### 角色区分

#### 用户

1. 注册与登录
2. 管理个人信息
3. 接受系统推送
4. 购买门票
5. 查询当前票务信息
6. 查询个人订单信息
7. 接受门票智能推荐
8. 评价交易
9. 竞拍票务

#### 管理员

1. 登录

2. 管理票务信息

3. 管理用户信息

4. 查看统计数据

5. 发布竞拍

   

### 用户注册

**基本流：**

1. 前端提示用户登录，用户输入用户名（不能重复）、密码、重复密码、手机号（不能重复），前端验证密码后向后端发送信息

2. 后端获取前端信息，在数据库中寻找是否存在相同用户名和手机号的用户，若存在，返回失败，若不存在，返回成功并将用户信息写入数据库

3. 前端接受信息，跳转至相应界面

**备选流：**

1. 存在相同用户名，提醒用户重新输入
2. 存在相同手机号，提醒用户找回密码



### 用户登录

**基本流：**

1. 前端提示用户登录，用户输入用户名和密码，前端向后端发送信息

2. 后端获取前端信息，在数据库中寻找用户，并返回是否登录成功与用户类型

3. 前端接受信息，跳转至相应界面

**备选流：**

1. 登录失败，提醒用户登录失败
2. 登录失败次数超过3次，提醒用户找回密码



### 用户购买

**基本流：**

1. 用户点击购买，向后端发送购买请求

2. 后端获取前端信息，在数据库中寻找写入订单信息，返回给前端订单号

3. 前端接受信息，展示订单号

**备选流：**

1. 用户未登录，提示用户登录



### 用户查看订单

**基本流：**

1. 用户点击订单，向后端发送购买请求

2. 后端获取前端信息，在数据库中寻找订单信息，返回给前端订单号

3. 前端接受信息，展示订单

**备选流：**

1. 用户未登录，提示用户登录



## 非功能需求





## 项目架构及设计

### 数据库设计

#### 物理模型

![](.\Jupiter document.assets\数据库物理模型.png)

#### 设计思想

​		数据库分为五个表，针对两个实体（用户、商品）。其中goods和user是两个实体类，用户分为用户名和昵称，用户可以对昵称进行修改。goodsdetail存放价格、库存等点击详细页面才需要获取的信息。在主页、分类页面不需要获得goodsdetail的数据，加快获得数据的速度。Orderlist表存放订单类，auction表存放拍卖信息，包括拍卖时间、初始价格、当前最高出价等等，关于几乎同时出价的处理在后端实现。



### 后端架构

​		我们设计并使用了两个后端，一个基于springboot的集成后端以及一个基于springcloud的微服务后端，两个后端向外提供了相同的RESTful API接口，可以进行无缝切换。

#### Spring Boot

##### 实现

此后端基于springboot实现，特点有：

- 采用MVC架构风格
- 使用 ORM 框架来访问数据库
- 使用 IoC在分层结构中注入具体接口的实现类以及其他参数
- 工程中体现出了合理的分层架构，包括表示层、控制层、 服务层、实体层等，始终遵循接口与实现分离原则

#### 安全

安全包括认证（Authentication）和授权（Authorization）。

springboot的后端采用拦截器的方式对前端请求进行拦截，Authentication部分首先调用login函数，验证前端发送的用户名和密码，若正确，将用户信息存储在session中，后端会在后续Authorization中利用存储在session中的用户信息进行用户权限的判断。

#### 部署

我们利用docker将后端部署于ec2中

#### Spring Cloud

##### 实现

我们采用了springcloud的微服务设计框架，设计并实现了由注册中心（eureka-server），用户服务（user-service），商品服务（goods-service），订单服务（order-service），用户中心（user-center），云端配置（config），单点登录中心（sso-server），集群监控（turbine），网关中心（zuul-server）。

- config（8805）： 我们采用云端配置，配置中心由[github](https://github.com/SJTUSummerProj2020/springCloudConfig)托管
- eureka（8801，8802）:  我们采用了双注册中心，一定程度上保证系统的稳定性
- goods-service（8883）：商品服务中心，提供商品相关接口
- order-service（8882：订单服务中心，提供订单相关接口
- user-service（8881）：用户服务中心，提供用户相关接口
- user-center（8884）：用户中心，提供用户与订单混合服务接口
- sso-server（8810）：单点登录中心，提供登录以及授权服务
- turbine（8804）：集群监控，对短路器进行监控
- zuul-server（8080）：向外暴露的网关接口，对请求进行转发

#### 安全

安全包括认证（Authentication）和授权（Authorization）。

springcloud的后端采用拦截器的方式对前端请求进行拦截，所有的请求都会进入Zuul网关，在那里我们设置过滤器来拦截请求。关于后端api可以分成三个部分，分别是无需登录即可访问、需要登录和需要管理员权限。过滤器通过调用sso微服务来完成对用户名和密码的验证，同时生成密钥作为cookie返给前端。密钥和用户信息被sso微服务存储在Redis数据库中，供所有微服务调用。权限的校验放在Zuul的过滤器中。过滤器会结合Redis数据库中的用户信息检验请求是否符合权限，并做出拦截。



## 后端测试

### Spring Boot

#### 测试

- 后端代码测试覆盖率：100%

#### 性能

- 优化后的并发性能能达到较高水平，100线程并发的均值均在100ms以下

![](.\Jupiter document.assets\100线程响应时间图.png)

#### 监控

我们采用了Actuator+Prometheus+Grafana的工具链。

通过Actuator将数据暴露给Prometheus,并通过Grafana绘制成图,方便横向对比不同容器的CPU占用量等信息。

![](.\Jupiter document.assets\Snipaste_2020-07-28_12-40-38.png)



### Spring Cloud

#### 性能

- 优化后的并发性能能达到较高水平，100线程并发的均值均在10ms级别

![](.\Jupiter document.assets\响应时间图springcloud.png)

#### 监控

我们利用率skywalking中的探针对系统情况进行检查，同时可利用turbine监控对断路器状况进行检查

![](.\Jupiter document.assets\image-20200906202617534.png)